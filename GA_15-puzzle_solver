# GA solver for 15 puzzle
import random
import codeskulptor
import simplegui

codeskulptor.set_timeout(20)
best_ever = None
#uuulllddruuldddruuurddlulddrrrulldrruuullddrurduullrdlurrlddruulddluludrurllrldrddruuullduluuullluuu
class Puzzle:
    """
    Class representation for the Fifteen puzzle
    """

    def __init__(self, puzzle_height, puzzle_width, initial_grid=None):
        """
        Initialize puzzle with default height and width
        Returns a Puzzle object
        """
        self._height = puzzle_height
        self._width = puzzle_width
        self._grid = [[col + puzzle_width * row
                       for col in range(self._width)]
                      for row in range(self._height)]

        if initial_grid != None:
            for row in range(puzzle_height):
                for col in range(puzzle_width):
                    self._grid[row][col] = initial_grid[row][col]

    def __str__(self):
        """
        Generate string representaion for puzzle
        Returns a string
        """
        ans = ""
        for row in range(self._height):
            ans += str(self._grid[row])
            ans += "\n"
        return ans

    def score_grid(self):
        grid = []
        for row in range(self.get_height()):
            new_row = []
            for col in range(self.get_width()):
                tmp = self.current_position(row, col)
                score = abs(tmp[1]-col)+abs(tmp[0]-row)
                #print "%s-%s + %s-%s = %s"%(tmp[1],col,tmp[0], row,  score)
                new_row.append(score)
            grid.append(new_row)
        
        for row in grid:
            print row
            
        return grid
    
    def flatten(self, alist=None):
        if alist == None: 
            alist = self._grid
            
        if not all([isinstance(item,list) for item in alist]):
            return alist
        
        val = []
        for item in alist:
            if not isinstance(item,list):
                val.append(item)
            else:
                val.extend(self.flatten(item))
        return val
        
    #####################################
    # GUI methods

    def get_height(self):
        """
        Getter for puzzle height
        Returns an integer
        """
        return self._height

    def get_width(self):
        """
        Getter for puzzle width
        Returns an integer
        """
        return self._width

    def get_number(self, row, col):
        """
        Getter for the number at tile position pos
        Returns an integer
        """
        return self._grid[row][col]

    def set_number(self, row, col, value):
        """
        Setter for the number at tile position pos
        """
        self._grid[row][col] = value

    def clone(self):
        """
        Make a copy of the puzzle to update during solving
        Returns a Puzzle object
        """
        new_puzzle = Puzzle(self._height, self._width, self._grid)
        return new_puzzle

    ########################################################
    # Core puzzle methods

    def current_position(self, solved_row, solved_col):
        """
        Locate the current position of the tile that will be at
        position (solved_row, solved_col) when the puzzle is solved
        Returns a tuple of two integers        
        """
        solved_value = (solved_col + self._width * solved_row)

        for row in range(self._height):
            for col in range(self._width):
                if self._grid[row][col] == solved_value:
                    return (row, col)
        assert False, "Value " + str(solved_value) + " not found"

    def update_puzzle(self, move_string):
        """
        Updates the puzzle state based on the provided move string
        """
        zero_row, zero_col = self.current_position(0, 0)
        for direction in move_string:
            if direction == "l":
                #assert zero_col > 0, "move off grid: " + direction
                if not (zero_col > 0):
                    return False
                self._grid[zero_row][zero_col] = self._grid[zero_row][zero_col - 1]
                self._grid[zero_row][zero_col - 1] = 0
                zero_col -= 1
            elif direction == "r":
                #assert zero_col < self._width - 1, "move off grid: " + direction
                if not (zero_col < self._width - 1):
                    return False
                self._grid[zero_row][zero_col] = self._grid[zero_row][zero_col + 1]
                self._grid[zero_row][zero_col + 1] = 0
                zero_col += 1
            elif direction == "u":
                #assert zero_row > 0, "move off grid: " + direction
                if not (zero_row > 0):
                    return False
                self._grid[zero_row][zero_col] = self._grid[zero_row - 1][zero_col]
                self._grid[zero_row - 1][zero_col] = 0
                zero_row -= 1
            elif direction == "d":
                #assert zero_row < self._height - 1, "move off grid: " + direction
                if not (zero_row < self._height - 1):
                    return False
                self._grid[zero_row][zero_col] = self._grid[zero_row + 1][zero_col]
                self._grid[zero_row + 1][zero_col] = 0
                zero_row += 1
            else:
                assert False, "invalid direction: " + direction
               
SOLUTION = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
SOLUTION_GRID = [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15]]
TESTBOARD = Puzzle(4,4,[[15,11,8,12],[14,10,9,13],[2,6,1,4],[3,7,5,0]])   
             
# population of 300 len strings

MAXPOP = 50
MAXSTRING = 110#100#300
MAXERR = 5
MAXADAPT = 3

ALLELE = "lrdu"

# helper fn to create chromosomes
def make_chrom(allele, maxstring):
    """
    return chromosome of len maxstring usng alleles
    """
    return [random.choice(allele) for dummy_pos in xrange(maxstring)]

def get_score(cur, solved):
    #return sum(map(lambda x,y:abs(x-y), cur.flatten()[12:], solved[12:]))**2 # DEBUG
    cur = cur._grid # 
    tot = 0
    for row_idx in xrange(4):
        for item_idx in xrange(4):
            #if cur[row_idx][item_idx]//4 == row_idx:
            tot += (126-5**abs((cur[row_idx][item_idx]//4)-row_idx)) + (126-5**abs((cur[row_idx][item_idx]%4)-item_idx))
            
#            if cur[row_idx][item_idx]%4 == item_idx:
#                tot+=50

    return tot

def fitness01(individual, environment):
    """
    Accepts an individual and returns its fitness score
    """
    # 1. create clone of test board
    board = environment.clone()
    
    # fitness is determined by score of board after a series of moves
    fitness = (get_score(board, SOLUTION), MAXSTRING)
    best = 0
    errlist = []
    
    try:
        assert len(fitness)==2
    except:
        print "Exception error: "
        print "   fitness:", fitness, type(fitness)
        assert False
    
    # 2. get genotype
    test_string = str(individual)
    
    # 3. apply test string to board with a max of MAXERR illegal moves
    # or until the list runs out. 
    # 4. keep running tally of best score and return that with list of illegal moves
    errcnt = 0
    for index in xrange(len(test_string)):
        if errcnt > MAXERR:
            break
        if board.update_puzzle(test_string[index]) is False:
            errlist.append(index)
            errcnt += 1
        else:
            fitness = min((fitness, best), (get_score(board, SOLUTION), index))
            fitness = list(fitness)
            fitness[0] = max(fitness[0]-fitness[1], 0)
    
    # 5. return fitness score and list of errors, and board?
    try:
        assert len(fitness)==2
    except:
        print "Exception error: "
        print "   fitness:", fitness, type(fitness)
        assert False
    return fitness, errlist, board


class Individual:
    def __init__(self, phenotype_fn, objective_fn, chromosome, fitness=None, p1=None, p2=None):
        self.environment = TESTBOARD
        self.genotype = chromosome
        self.parent1 = p1	# another individual
        self.parent2 = p2	# another individual
        self.phenotype = phenotype_fn		# decode genotype
        self.objective = objective_fn		# determine fitness
        self.fitness = fitness
        
    def __str__(self):
        return ''.join(self.genotype)
    
    def __cmp__(self, other):
#        assert isinstance(other, Individual), str(other)
#        assert isinstance(self.fitness, list), self.fitness[0]
#        assert isinstance(other.get_fitness(), list), other.get_fitness()
#        try:
#            assert len(other.get_fitness())==2
#            assert len(self.get_fitness())==2
#        except:
#            print "Exception error: "
#            print "   other:", other.get_fitness(), other
#            print "    self:", self.get_fitness(), self
#            assert False
            
        if self.get_fitness()[0] < other.get_fitness()[0]:
            return 1#-1
        elif self.get_fitness()[0] > other.get_fitness()[0]:
            return -1#1
        else:
            return 0
    
    def get_fitness(self):
        return self.fitness #self.objective(self, self.environment)
    
    def crossover(self, loc, string):
        #tmp = self.genotype[loc:]
        self.genotype = self.genotype[:loc]+string
        self.fitness = None
        #return loc, tmp
        
    def mutate(self, allele, nbr=1):
        for dummy_n in xrange(nbr):  
            rand = random.randrange(4)
            if rand == 0:
                loc = random.randrange(len(self.genotype))
                self.genotype[loc] = random.choice(allele)
            elif rand == 1: 
                xxx = self.genotype.pop(random.randrange(MAXSTRING))
                self.genotype.append(xxx)
                assert len(self.genotype) == MAXSTRING, str(len(self.genotype))+str(self)
            elif rand == 2:
                pairs = ['rl','lr','ud','du']
                found = str(self).find(random.choice(pairs))
                
                if found == -1:
                    return
                
                self.genotype.pop(found)
                self.genotype.append(random.choice(ALLELE))
                self.genotype.pop(found)
                self.genotype.append(random.choice(ALLELE))
                assert len(self.genotype) == MAXSTRING
            else:
                #no change
                pass
    
    def adapt(self, adaptations):
        """
        run through a number of adaptation before determining final fitness
        """
        score = None
        
        for dummy_adap in xrange(adaptations):
            score,changes,env = self.objective(self, self.environment)
            rem = []
            changes.reverse()
            for change in changes:
                rem.append(self.genotype.pop(change))
            rem.reverse()
            self.genotype.extend(rem)
        #assert len(self.genotype) == MAXSTRING  
        self.fitness = score
        return score, str(self)
    
    def clone(self):
        return Individual(self.phenotype, self.objective, self.genotype[:], tuple(self.fitness))

    
# Create the initial population
s = []
# best ever
#s.append('luldrruudldlurdruulluldrldrldrrulldrruulddrruullldduuddrruulldrdrulurdlldrrlurdrdrullulurduldullullu'+'llllllllll')
# my best
#s.append('ullluurrddlluurrddruulddllurrrddllurdlurruldrdllurruldrdllurdluldrrrullluurddluurrdllurrdlurdrdllurr'+'llllllllll')
# (16, 93)
#s.append('ullluurrddlluurrddruulddllurrrddllurdlurruldrdllurruldrdllurdluldrrrullluurddluurrrddlllurrulluluull')
# loaded
#s.append('uuulllddruuldddruuurddlulddrrrulldrruuulldruldddrurulldrrdlluldrrruuuldrulldrdllurrdllurdlururdruuuu'+'llllllllll')
#(64, 93) uuulllddruuldddruuurddlulddrrrulldrruuulldruldddrurulldrrdlluldrrruuuldrulldrdllurrdllurdluruluuuuul
#s.append('uuulllddruuldddruuurddlulddrrrulldrruuullddrurduullrdlurrlddruulddluludrurllrldrddruuullduluuullluuu'+'llllllllll')
#[3745, 71] 
#s.append('lulluurrddlluurrddrulddllurrrdllurrulddluurruldrdlullurrdddlluuurdrdluullulllllluuulululululllllluul'+'llllllllll')
#[3777, 71]
#s.append('lulluurrddlluurrddrulddllurrrdllurrulddllurruruldrdllurddluulurrdddlluuulllullllllllllullullullulluu'+'llllllllll')
#[3805, 91] 
#s.append('ullluurrddlluurrddruulddllurrrddllurdlurruldrdllurruldrdllurdluldrrrullluurddluurrdrlrullduluululuuu'+'llllllllll')
#[3774, 98] 
#s.append('ullluurrddlluurrddruulddllurrrddllurdlurruldrdllurruldrdllurdluldrrrullluurddluurrdllurrdlurdrdlluuu'+'llllllllll')
#(3845, 91)
#s.append('ullluurrddlluurrddruulddllurrrddllurdlurruldrdllurruldrdllurdluldrrrullluurddluurrdrulldrulluulluluu'+'llllllllll')
#Generation  45 (3851, 93) 
#s.append('ullluurrddlluurrddruulddllurrrddllurdlurruldrdllurruldrdllurdluldrrrullluurddluurrdrulldrrulllllllll'+'llllllllll')
#Generation  170 (3863, 81) 
#s.append('ullluurrddlluurrddruulddllurrrddllurruldrdllurruldrdllurdluldrrulluurddluurdrrullluuuuuuuluuuuluuull'+'llllllllll')
#Generation  19 (3871, 81) 
#s.append('lulluurrddlluurrddruulddllurrrddllurruldrdllurruldrdllurdluldrrulluurddluurdrrulllullluuuuuuuulllulu'+'llllllllll')
#Generation  121 (3885, 83) 
s.append('lulluurrddlluurrddruulddllurrrddllurruldrdllurruldrdllurdluldrrulluurddluurdrrulldluuululuuluulluull'+'llllllllll')
# 110 solution
s.append('lulluurrddlluurrddruulddllurrrddllurruldrdllurruldrdllurdluldrrulluurddluurdrrulldlurrdrdlluurrdluldruldrrulll')

####
# Continent 2 Solutions
####
#Generation  340 (3823, 73) 
#s.append('lluuruldlddruuldrrruulldrulldrdldrurdruuulddrululdrullddrrdlurdruluulldrullllluullluulllluudllllllululuululllu')
#s.append('lluuruldlddruuldrrruulldrulldrdldrurdruuulddrululdrullddrrdlurdruluullddruulluulllluuluullldlluuluululuulluull')
#Generation  69 (3845, 83) 
s.append('lluuruldlddruuldrrruulldrulldrdldrurdruuulddrululdrullddrrdlurdruluullddruuldddruluuuulluluulluluuuuuluuulllul')

####
# Continent 3 Solutions
####
#Generation  90 (3821, 83) luuldluurddrdllurdlurruuldrdruulllddrrrulullddrrruullldrulrdruldldrrrdllururullldudulluullddlluuulllllulllllll
#Generation  92 (3823, 81) luuldluurddrdllurdlurruuldrdruulllddrrrulullddrrruullldrulrdruldldrrrdllururullldulluullllllrlllulllulllllluuu
#Generation  93 (3825, 79) luuldluurddrdllurdlurruuldrdruulllddrrrulullddrrruullldrruldldrrrdllururulllrlrlllllulllulrdrdllllluuuuluullll
#Generation  99 (3827, 77) luuldluurddrdllurdlurruuldrdruulllddrrrulullddrrruullldrruldldrrrdllururulllrlllluuulllllurrlluulllllullullull
#Generation  103 (3829, 75) luuldluurddrdllurdlurruuldrdruulllddrrrulullddrrruullldrruldldrrrdllururulllllllluullulllluullluuulllullllllll
#Generation  120 (3831, 73) 
s.append('luuldluurddrdllurdlurruuldrdruulllddrurullddrrruullldrruldldrrrdllururulllllllllllllluulluulullluullluuullllul')

####
# Continent 4 Solutions
####
#Generation  135 (3819, 77) llluurddluurdruuldrulldrdlurddruruulldddluurdrrulllddrrurululdrldruulldrulrlrlluululllllluuuuuuluuuulululllluu
#Generation  138 (3821, 75) llluurddluurdruuldrulldrdlurddruruulldddluurdrrulllddrrurululdrldruulldrulrlulllllluuuuuuldluuuulululllluuluul
#Generation  165 (3825, 71) 
s.append('llluurddluurdruuldrulldrdlurddruruulldddluurdrrulllddrrurululddruulldruluuullllllllluuluuuuduuuluuulllullluluu')

####
# Continent 5 Solutions
####
#Generation  82 (3813, 107) llurdlurullddrrruulldrdruulullddrruldluddrrruuulllddrrruullldudddrudruruulldldurldrrludurldrrlullduddrrluuuluu
#Generation  89 (3817, 103) llurdlurullddrrruulldrdruulullddrruldldrrruuulllddrrruullldddrudruruulldldurldrrludrrulrllldurldudurlurlulllll
#Generation  99 (3823, 97) llurdlurullddrrruulldrdruulullddrruldldrrruuulllddrrruullldddrruruullddudrrudululrlldudrldrulduurllulululluulu
#Generation  105 (3825, 95) llurdlurullddrrruulldrdruulullddrruldldrrruuulllddrrruullldddrruruullddudrrudulullduddrulduudurllululululllluu
#Generation  111 (3831, 89) llurdlurullddrrruulldrdruulullddrruldldrrruuulllddrrruullldddrruruullddrrulullduddrulduurlllllllullluulullllul
#Generation  117 (3839, 97) llurdlurullddrrruulldrdruulullddrruldldrrruuulllddrrruullldddrruruulldldrrrullldrlrldruldurldurluulullulluulll
#Generation  121 (3847, 97) llurdlurullddrrruulldrdruulullddrruldldrrruuulllddrrruullldddrruruulldldrrrullldrldruldurlduruduullululluulllu
#Generation  188 (3861, 83) llurdlurullddrrruulldrdruulullddrrulddrruuulllddrrruullldddrruruulldldrrrulllddruluuullllllllllluuuululuululul
#Generation  273 (3865, 87) 
s.append('llurdlurullddrrruulldrdruulullddrrulddrruuulllddrrruullldddrruruulldldrrrulllddruluurdlulurdullulllluuuluuluul')

####
# Continent 6 Solutions
####
#Generation  179 (3771, 61) 
s.append('uulddluldrruldrruuldldrrulluurrdlllurrrddlllurdldrrulluurddluuuullulululluuuuululuuullluuurrlllllluuullllluuul')

####
# Continent 7 Solutions
####
#Generation  83 (3687, 105) 
s.append('uulduldrdruululdrulrrdlduullddrrdluuulddrdrrlllrluudrruldurrlrlrlldrrdlurldurlrlrlrlldurlrrdluldrulrluulrluluu')

####
# combo Solutions
####
#106 solution 
s.append('lulluurrddlluurrddruulddllurrrddllurruldrdllurruldrdllurdluldrrulluurddluurdrrulldlurrdrdlluurrdllurdrulllllll')
#108 solution
s.append('lulluurrddlluurrddruulddllurrrddllurruldrdllurruldrdllurdluldrrulluurddluurdrrulldlurdurdrdlluurrdllurdrulllll')
#[3849, 87] lulluurrddlluurrddruulddllurrrddllurruldrdllurruldrdllurdluldrrulluurddluurdrruldlludurluluuululuulluullllllul
#[3885, 99] lulluurrddlluurrddruulddllurrrddllurruldrdllurruldrdllurdluldrrulluurddluurdrrulldlurrdrdlluurdluldullullluull
#[3883, 85] lulluurrddlluurrddruulddllurrrddllurruldrdllurruldrdllurdluldrrulluurddluurdrrulldlurluuullruuluulluluulullllu
#[3847, 81] lulluurrddlluurrddruulddllurrrddllurruldrdllurruldrdllurdluldrrulluurddluurdrulldullllllllllllllllllluuulluull
#[3811, 69] 
s.append('lluuruldlddruuldrrruulldrulldrdldrurdruuulddrululldrrullddruldrrulurllulluulllululllululllruuulluuluuuulllllll')
#[3831, 73] 
s.append('lulluurrddlluurrddruulddllurrrddllurruldrdllurruldrdllurdluldrrulluurddluuuuluullulullulllullllluulluluululluu')
#[3879, 89] 
s.append('lulluurrddlluurrddruulddllurrrddllurruldrdllurruldrdllurdluldrrulluurddluurdrrulldludrduluuuuulluluuullluuuuuu')

#lulluurrddlluurrddruulddllurrrddllurruldrdllurruldrdllurdluldrrulluurddluurdrrulldlurrdrullluuuullllluluuuuulu
#s.append('uulllddruurddruldluurdruullldrrullddrruulddrruullddrululdddrruulldrdrulurdlludduduududuulllllulllluu')
#s.append('uulllddruurddruldluurdruullldrrullddrruulddrruullddrululdddrruulldrdrulurdllurdrdrullulurduluuluuuuu')
#s.append('uulllddruurddruldluurdruullldrrullddrruulddrruullddrululdddrruulldrdrulurdllurdrdrulluldudduuullluuu')
#s.append('uulllddruurddruldluurdruullldrrullddrruulddrruullddrululdddrruulldrdrulurdllurdrdrulluldrluuduuuuuuu')
#s.append('uulllddruurddruldluurdruullldrrullddrruulddrruullddrululdddrruulldrdrulurdllurdrdrullulurlduululluuu')
#s.append('uulllddruurddruldluurdruullldrrullddrruulddrruullddrululdddrruulldrdrulurdllurdrdrullulurdudullullul')
#s.append('uulllddruurddruldluurdruullldrrullddrruulddrruullddrululdddrruulldrdrulurdllurdrdrulluludulluuuuuulu')
#s.append('uulllddruurddruldluurdruullldrrullddrruulddrruullddrululdddrruulldrdrulurdllurdrdrulluldduuudullllll')
#s.append('uulllddruurddruldluurdruullldrrullddrruulddrruullddrululdddrruulldrdrulurdllurdrdrulluldrluuduuuuuuu')
#s.append('uulllddruurddruldluurdruullldrrullddrruulddrruullddrululdddrruulldrdrulurdllurdrdrulluldudduuurllluu')
#s.append('uulllddruurddruldluurdruullldrrullddrruulddrruullddrululdddrruulldrdrulurdllurdrdrulluldrlurlulllllu')
# [50, 46] uuulllddruuldddruuurddlulddrrrulldrruullddruruuruuuuruuurruuurrruururururuuurrrudrruuuuuruuuuuuuuruu
#best_ever = Individual(None,
#                       fitness01,list('luldrruudldlurdruulluldrldrldrrulldrruulddrruullldduuddrruulldrdrulurdlldrrlurdrdrullulurduldullullu'))
#best_ever = s[0]
#my_best = Individual(None,
#                     fitness01,list('ullluurrddlluurrddruulddllurrrddllurdlurruldrdllurruldrdllurdluldrrrullluurddluurrdllurrdlurdrdllurr'))#uldrullldrrrdluldrruulll'))


seed_pop = [Individual(None,
                         fitness01,
                         list(s[indiv])) for indiv in xrange(len(s))] 

#my_best = seed_pop[1]

population = [Individual(None,
                         fitness01,
                         make_chrom(ALLELE, MAXSTRING)) for indiv in xrange(MAXPOP-len(seed_pop))]    

#population[0] = Individual(None,
#                         fitness01,list(s))
population += seed_pop

# helper fn to create the selection wheel
def make_wheel(alist):
    return [alist[val]+sum(alist[0:val]) for val in xrange(len(alist))]

# helper fn for making selection from distribution list
def select_rand(alist):
    val = random.random()
    for idx in range(len(alist)):
        if val < alist[idx]:
            return idx#, val

# helper fn for crossover
def crossover(par1,par2):
    cross = random.randrange(0,MAXSTRING)
    par1_gen = list(str(par1)[cross:])
    par2_gen = list(str(par2)[cross:])
    
    par1.crossover(cross, par2_gen)
    par2.crossover(cross, par1_gen)        
        
# main generation function
def generation(population):
    global best_ever
    # add some new blood
#    population.append(Individual(None,
#                         fitness01,make_chrom(ALLELE, MAXSTRING)))
    
    # apply adaptations and determine fitness
    for indiv in population:
        indiv.adapt(MAXADAPT)
        
    # sort population by best
    population.sort()
    
#    if best_ever != None:
#        assert best_ever != None and population[0] != None
#        print best_ever.get_fitness(), population[0].get_fitness()
        
    if best_ever is None:
        best_ever = population[0].clone()
    elif best_ever.get_fitness()[0] < population[0].get_fitness()[0]:
        best_ever = population[0].clone()
        
    for good in population[:10]:
        print good.get_fitness(), good	# print the best
    
#    # get mating pool
#    # establish total points avail and sort 
#    selected = population[:len(population)//2]
#    tot = float(sum(1/float(max(indiv.get_fitness()[0],0000000.1)) for indiv in selected))
#
#    # create pobability distribution for sorted population
#    wheel = make_wheel([(1/float(max(p.get_fitness()[0],0000000.1)))/tot for p in selected])

    
    selected = population[:len(population)//2]
    tot = float(sum(indiv.get_fitness()[0] for indiv in selected))
    wheel = make_wheel([p.get_fitness()[0]/tot for p in selected]) 
    
    # create the new selection pool

    if random.choice([True, False]):
        section = random.randrange(MAXSTRING//2)
        new_blood = Individual(None,
                         fitness01,list(str(population[0])[section:section+5]*22))#20)) # modified for len 110
        
        pool = [best_ever.clone(), population[0], population[-1], new_blood]#, my_best]
    else:
        section = random.randrange(MAXSTRING-10)
        new_blood = Individual(None,
                         fitness01,list(str(population[0])[section:section+10]*11))#10))  # modified for len 110
        pool = [population[0], population[-1], new_blood]
    
    extinction = all(xxx.get_fitness()[0]==selected[0].get_fitness()[0] for xxx in selected)
    for sel in range(MAXPOP-len(pool)):
        if extinction and sel>6:
            pool.append(Individual(None,
                             fitness01,
                             make_chrom(ALLELE, MAXSTRING)))
        else:
            pool.append( population[ select_rand(wheel) ].clone() )
#Generation  108 (3845, 91) ullluurrddlluurrddruulddllurrrddllurdlurruldrdllurruldrdllurdluldrrrullluurddluurrdrulldrulluulluluu
             
    # random pairing and crossover
    random.shuffle(pool)
    for pair in range(0, len(pool), 2):
        assert len(pool[pair].genotype)==MAXSTRING, str(len(pool[pair].genotype))+str(pool[pair])
        #assert len(pool[pair+1].genotype)==MAXSTRING
        crossover(pool[pair], pool[pair+1])
    
    # mutation
    for p in pool:
        p.mutate(ALLELE,1)
    
    # now we have our next generation
    return pool

#for x in xrange(10):
#    population = generation(population)
#    print

# timer handler
def timer_handler():
    click()
    
# Handler for mouse click
def click():
    global population, message
    population = generation(population)
    print "Generation ", message, best_ever.get_fitness(), best_ever, "\n"
    message+=1

# Handler to draw on canvas
message = 0
def draw(canvas):
    canvas.draw_text("Generation:"+str(message), [50,112], 24, "Red")

# Create a frame and assign callbacks to event handlers
#frame = simplegui.create_frame("Home", 300, 200)
#frame.add_button("Click me", click)
#frame.set_draw_handler(draw)
timer = simplegui.create_timer(1000*11, timer_handler)

# Start the frame animation
#frame.start()
timer.start()
click()
